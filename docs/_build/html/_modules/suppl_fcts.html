<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>suppl_fcts &#8212; Gemini  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for suppl_fcts</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="c1"># Core imports (safe for Sphinx)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">basix.ufl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx.io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tqdm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ufl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="c1"># Conditional imports for PETSc and MPI</span>
<span class="k">if</span> <span class="s1">&#39;SPHINX_BUILD&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
    <span class="c1"># Mock or minimal imports for Sphinx</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py.PETSc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarType</span>
    <span class="n">comm</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Full imports for runtime</span>
    <span class="k">if</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="s2">&quot;petsc4py&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: petsc4py is required for this module.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py.PETSc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarType</span>  <span class="c1"># Fallback for runtime</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">dolfinx</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">has_petsc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: DOLFINx must be compiled with PETSc enabled.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">petsc4py.PETSc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarType</span>
    
    <span class="kn">import</span><span class="w"> </span><span class="nn">mpi4py.MPI</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">MPI</span>
    <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Add root directory to sys.path</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;./&#39;</span><span class="p">))</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root_dir</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IO_fcts</span><span class="w"> </span><span class="kn">import</span> <span class="n">print0</span>

<span class="c1"># Remaining imports (dependent on above)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">XDMFFile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx</span><span class="w"> </span><span class="kn">import</span> <span class="n">fem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem</span><span class="w"> </span><span class="kn">import</span> <span class="n">assemble_scalar</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">create_interpolation_data</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Expression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">meshtags</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dolfinx.fem.petsc</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearProblem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ufl</span><span class="w"> </span><span class="kn">import</span> <span class="n">dx</span><span class="p">,</span> <span class="n">Measure</span>


<span class="c1">#%%</span>
<span class="c1">#----------------------------------------Interpolation &amp; Projection----------------------------------------</span>
<div class="viewcode-block" id="project_expression">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.project_expression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">project_expression</span><span class="p">(</span><span class="n">f_expr</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bcgs&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;hypre&quot;</span><span class="p">}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic L²‐projection of the UFL expression f_expr onto the function space V.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">f_expr</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">LinearProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[],</span> <span class="n">petsc_options</span><span class="o">=</span><span class="n">petsc_options</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span></div>


<div class="viewcode-block" id="project_tensor_expression">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.project_tensor_expression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">project_tensor_expression</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bcgs&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;hypre&quot;</span><span class="p">}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    L²‐project the tensor‐vector product K⋅g onto V.  </span>
<span class="sd">    K can be a tensor‐valued Function or a flattened MixedElement Function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh_dim</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span>
    <span class="c1"># rebuild K as a UFL matrix if needed</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="s2">&quot;ufl_shape&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">mesh_dim</span><span class="p">,</span> <span class="n">mesh_dim</span><span class="p">):</span>
        <span class="n">K_tensor</span> <span class="o">=</span> <span class="n">K</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="s2">&quot;ufl_shape&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">ufl_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">mesh_dim</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">K_tensor</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">([</span>
            <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">mesh_dim</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh_dim</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh_dim</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported shape for K: </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;ufl_shape&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">K_tensor</span> <span class="o">*</span> <span class="n">g</span>
    <span class="k">return</span> <span class="n">project_expression</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">petsc_options</span><span class="o">=</span><span class="n">petsc_options</span><span class="p">)</span></div>


<div class="viewcode-block" id="interpolate_expression">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.interpolate_expression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate_expression</span><span class="p">(</span><span class="n">f_expr</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nodal interpolation of the UFL expression `f_expr` into FunctionSpace V.</span>
<span class="sd">    Uses the C++‐level interpolator (via Python wrapper) on all local cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="c1"># Wrap your UFL expression—must be true UFL (using Functions, Constants, ufl.grad, etc.)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">f_expr</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">interpolation_points</span><span class="p">())</span>
    <span class="c1"># One‐liner: C++ does the mesh‐inference and nodal eval</span>
    <span class="n">f</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="interpolate_tensor_expression">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.interpolate_tensor_expression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate_tensor_expression</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nodal interpolate the tensor–vector product K⋅g into V.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="s2">&quot;ufl_shape&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">ufl_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">Kmat</span> <span class="o">=</span> <span class="n">K</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Kmat</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">([</span>
            <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="k">return</span> <span class="n">interpolate_expression</span><span class="p">(</span><span class="n">Kmat</span> <span class="o">*</span> <span class="n">g</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span></div>


<div class="viewcode-block" id="interpolate_to_mesh_order">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.interpolate_to_mesh_order">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate_to_mesh_order</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">mesh_order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re‐interpolate any Function to CG(mesh_order) for output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">ufl_shape</span>
    <span class="n">cellname</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span><span class="o">.</span><span class="n">_cellname</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">elt</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">ufl</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">cellname</span><span class="p">,</span> <span class="n">mesh_order</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">elt</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">ufl</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">cellname</span><span class="p">,</span> <span class="n">mesh_order</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">elt</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">ufl</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">cellname</span><span class="p">,</span> <span class="n">mesh_order</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported shape: </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">Vt</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">elt</span><span class="p">)</span>
    <span class="n">f_interp</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">Vt</span><span class="p">)</span>
    <span class="n">f_interp</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f_interp</span></div>


<span class="c1">#%%</span>
<span class="c1">#----------------------------------------Computation &amp; Analysis--------------------------------------------</span>
<div class="viewcode-block" id="compute_integral_quantities">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.compute_integral_quantities">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_integral_quantities</span><span class="p">(</span>
    <span class="n">configs</span><span class="p">,</span>
    <span class="n">myResults</span><span class="p">,</span>
    <span class="n">my_integr_vars</span><span class="p">,</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">subdomains</span><span class="p">,</span>
    <span class="n">boundaries</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwarg</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute surface and volume integrals or averages for a list of output variables.</span>

<span class="sd">    1. Reads variable names and integration types from config.</span>
<span class="sd">    2. Prepares region labels (boundaries/subdomains) and computes area/volume if needed.</span>
<span class="sd">    3. Performs integration (or averaging) over surface or volume for each variable.</span>
<span class="sd">    4. Fills my_integr_vars with results and assembles final output arrays.</span>
<span class="sd">    5. Optionally saves results as CSV files in the output folder.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    configs : dict</span>
<span class="sd">        Dictionary containing &#39;output&#39; key with:</span>
<span class="sd">            - &#39;integral_vars&#39;: list of variable names with integration type suffix</span>
<span class="sd">            - &#39;res_fldr&#39;: results folder path for saving files</span>

<span class="sd">    myResults : dict</span>
<span class="sd">        Dictionary of solution fields (dolfinx.Functions or arrays) to be integrated.</span>

<span class="sd">    my_integr_vars : dict</span>
<span class="sd">        Dictionary where computed integrals/averages will be stored.</span>

<span class="sd">    mesh : dolfinx.mesh.Mesh</span>
<span class="sd">        Mesh over which integration is performed.</span>

<span class="sd">    subdomains : dolfinx.mesh.MeshTags</span>
<span class="sd">        Cell-wise region identifiers (e.g., white/gray matter).</span>

<span class="sd">    boundaries : dolfinx.mesh.MeshTags</span>
<span class="sd">        Facet-wise region identifiers (for surface integration).</span>

<span class="sd">    rank : int</span>
<span class="sd">        MPI rank for controlling print statements.</span>

<span class="sd">    **kwarg : dict</span>
<span class="sd">        Optional:</span>
<span class="sd">            - save_data : bool</span>
<span class="sd">                Whether to save results to disk (default: True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        - surf_int_values : list or empty</span>
<span class="sd">            List of surface integrals/averages and IDs.</span>
<span class="sd">        - surf_int_header : str</span>
<span class="sd">            CSV header string for surface data.</span>
<span class="sd">        - volu_int_values : list or empty</span>
<span class="sd">            List of volume integrals/averages and IDs.</span>
<span class="sd">        - volu_int_header : str</span>
<span class="sd">            CSV header string for volume data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_integral_quantities: Starting...&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;save_data&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span><span class="p">:</span>
        <span class="n">save_data</span> <span class="o">=</span> <span class="n">kwarg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;save_data&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">save_data</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">surf_int_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">surf_int_header</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">surf_int_dat_struct</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">volu_int_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">volu_int_header</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">volu_int_dat_struct</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">res_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">myResults</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">int_vars</span> <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;integral_vars&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">print0</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">int_vars</span><span class="p">)</span><span class="si">}</span><span class="s2"> variables for integration.&quot;</span><span class="p">)</span>
        <span class="n">int_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">intvar</span> <span class="ow">in</span> <span class="n">int_vars</span><span class="p">:</span>
            <span class="n">int_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intvar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Surface integrals or averages</span>
        <span class="k">if</span> <span class="s1">&#39;surfave&#39;</span> <span class="ow">in</span> <span class="n">int_types</span><span class="p">:</span>
            <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Preparing surface areas for &#39;surfave&#39;&quot;</span><span class="p">)</span>
            <span class="n">bound_label</span><span class="p">,</span> <span class="n">n_bound_label</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>
            <span class="n">bound_label</span> <span class="o">=</span> <span class="n">bound_label</span><span class="p">[</span><span class="n">bound_label</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">n_bound_label</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bound_label</span><span class="p">)</span>
            <span class="n">bound_areas</span> <span class="o">=</span> <span class="n">compute_boundary_area</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">bound_label</span><span class="p">,</span> <span class="n">n_bound_label</span><span class="p">)</span>
            <span class="n">surf_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bound_label</span><span class="p">)</span>
            <span class="n">surf_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bound_areas</span><span class="p">)</span>
            <span class="n">surf_int_header</span> <span class="o">+=</span> <span class="s1">&#39;surf ID,area,&#39;</span>
            <span class="n">surf_int_dat_struct</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">,</span><span class="si">%e</span><span class="s1">,&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;surfint&#39;</span> <span class="ow">in</span> <span class="n">int_types</span><span class="p">:</span>
            <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Preparing surface IDs for &#39;surfint&#39;&quot;</span><span class="p">)</span>
            <span class="n">bound_label</span><span class="p">,</span> <span class="n">n_bound_label</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>
            <span class="n">bound_label</span> <span class="o">=</span> <span class="n">bound_label</span><span class="p">[</span><span class="n">bound_label</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">n_bound_label</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bound_label</span><span class="p">)</span>
            <span class="n">surf_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bound_label</span><span class="p">)</span>
            <span class="n">surf_int_header</span> <span class="o">+=</span> <span class="s1">&#39;surf ID,&#39;</span>
            <span class="n">surf_int_dat_struct</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">,&#39;</span>

        <span class="c1"># Volume integrals or averages</span>
        <span class="k">if</span> <span class="s1">&#39;voluave&#39;</span> <span class="ow">in</span> <span class="n">int_types</span><span class="p">:</span>
            <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Preparing subdomain volumes for &#39;voluave&#39;&quot;</span><span class="p">)</span>
            <span class="n">subdom_label</span><span class="p">,</span> <span class="n">n_subdom_label</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span>
            <span class="n">subdom_vols</span> <span class="o">=</span> <span class="n">compute_subdm_vol</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">,</span> <span class="n">subdom_label</span><span class="p">,</span> <span class="n">n_subdom_label</span><span class="p">)</span>
            <span class="n">volu_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subdom_label</span><span class="p">)</span>
            <span class="n">volu_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subdom_vols</span><span class="p">)</span>
            <span class="n">volu_int_header</span> <span class="o">+=</span> <span class="s1">&#39;volu ID,volu,&#39;</span>
            <span class="n">volu_int_dat_struct</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">,</span><span class="si">%e</span><span class="s1">,&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;voluint&#39;</span> <span class="ow">in</span> <span class="n">int_types</span><span class="p">:</span>
            <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Preparing subdomain IDs for &#39;voluint&#39;&quot;</span><span class="p">)</span>
            <span class="n">subdom_label</span><span class="p">,</span> <span class="n">n_subdom_label</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span>
            <span class="n">volu_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subdom_label</span><span class="p">)</span>
            <span class="n">volu_int_header</span> <span class="o">+=</span> <span class="s1">&#39;volu ID,&#39;</span>
            <span class="n">volu_int_dat_struct</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">,&#39;</span>

        <span class="c1"># Compute integrals</span>
        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Computing integrals...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">intvar</span> <span class="ow">in</span> <span class="n">int_vars</span><span class="p">:</span>
            <span class="n">intvar_parts</span> <span class="o">=</span> <span class="n">intvar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="n">var2int</span> <span class="o">=</span> <span class="n">intvar_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">magn_indicator</span> <span class="o">=</span> <span class="p">(</span><span class="n">intvar_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;magn&#39;</span><span class="p">)</span>
            <span class="n">int_type</span> <span class="o">=</span> <span class="n">intvar_parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">var2int</span> <span class="ow">in</span> <span class="n">res_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">int_type</span> <span class="o">==</span> <span class="s1">&#39;surfint&#39;</span><span class="p">:</span>
                    <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">surface_integrate</span><span class="p">(</span>
                        <span class="n">myResults</span><span class="p">[</span><span class="n">var2int</span><span class="p">],</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">bound_label</span><span class="p">,</span> <span class="n">n_bound_label</span><span class="p">,</span> <span class="n">magn_indicator</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">int_type</span> <span class="o">==</span> <span class="s1">&#39;voluint&#39;</span><span class="p">:</span>
                    <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_integrate</span><span class="p">(</span>
                        <span class="n">myResults</span><span class="p">[</span><span class="n">var2int</span><span class="p">],</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">,</span> <span class="n">subdom_label</span><span class="p">,</span> <span class="n">n_subdom_label</span><span class="p">,</span> <span class="n">magn_indicator</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">int_type</span> <span class="o">==</span> <span class="s1">&#39;surfave&#39;</span><span class="p">:</span>
                    <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">surface_integrate</span><span class="p">(</span>
                        <span class="n">myResults</span><span class="p">[</span><span class="n">var2int</span><span class="p">],</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">bound_label</span><span class="p">,</span> <span class="n">n_bound_label</span><span class="p">,</span> <span class="n">magn_indicator</span><span class="p">)</span>
                    <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span> <span class="o">/</span> <span class="n">bound_areas</span>
                <span class="k">elif</span> <span class="n">int_type</span> <span class="o">==</span> <span class="s1">&#39;voluave&#39;</span><span class="p">:</span>
                    <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_integrate</span><span class="p">(</span>
                        <span class="n">myResults</span><span class="p">[</span><span class="n">var2int</span><span class="p">],</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">,</span> <span class="n">subdom_label</span><span class="p">,</span> <span class="n">n_subdom_label</span><span class="p">,</span> <span class="n">magn_indicator</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Warning: &#39;</span> <span class="o">+</span> <span class="n">int_type</span> <span class="o">+</span> <span class="s1">&#39; is not recognised!&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Warning: &#39;</span> <span class="o">+</span> <span class="n">var2int</span> <span class="o">+</span> <span class="s1">&#39; variable cannot be integrated - variable undefined!&#39;</span><span class="p">)</span>

        <span class="c1"># Organize into surface/volume groups</span>
        <span class="k">for</span> <span class="n">intvar</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">my_integr_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">int_types</span> <span class="o">=</span> <span class="n">intvar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">int_types</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;surf&#39;</span><span class="p">:</span>
                <span class="n">surf_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">])</span>
                <span class="n">surf_int_header</span> <span class="o">+=</span> <span class="n">intvar</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span>
                <span class="n">surf_int_dat_struct</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%e</span><span class="s1">,&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">volu_int_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_integr_vars</span><span class="p">[</span><span class="n">intvar</span><span class="p">])</span>
                <span class="n">volu_int_header</span> <span class="o">+=</span> <span class="n">intvar</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span>
                <span class="n">volu_int_dat_struct</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%e</span><span class="s1">,&#39;</span>

        <span class="c1"># Convert to numpy arrays</span>
        <span class="n">surf_int_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">surf_int_values</span><span class="p">)</span>
        <span class="n">surf_int_values</span> <span class="o">=</span> <span class="n">surf_int_values</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">volu_int_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">volu_int_values</span><span class="p">)</span>
        <span class="n">volu_int_values</span> <span class="o">=</span> <span class="n">volu_int_values</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># Save to disk</span>
        <span class="k">if</span> <span class="n">save_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">surf_int_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span>
                    <span class="n">configs</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;res_fldr&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;surface_integrals.csv&#39;</span><span class="p">,</span>
                    <span class="n">surf_int_values</span><span class="p">,</span> <span class="n">surf_int_dat_struct</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">header</span><span class="o">=</span><span class="n">surf_int_header</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">volu_int_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span>
                    <span class="n">configs</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;res_fldr&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;volume_integrals.csv&#39;</span><span class="p">,</span>
                    <span class="n">volu_int_values</span><span class="p">,</span> <span class="n">volu_int_dat_struct</span><span class="p">,</span>
                    <span class="n">header</span><span class="o">=</span><span class="n">volu_int_header</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Integration completed.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">surf_int_values</span><span class="p">,</span> <span class="n">surf_int_header</span><span class="p">,</span> <span class="n">volu_int_values</span><span class="p">,</span> <span class="n">volu_int_header</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;No variables have been defined for integration!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="compute_my_variables">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.compute_my_variables">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_my_variables</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">K3</span><span class="p">,</span> <span class="n">beta12</span><span class="p">,</span> <span class="n">beta23</span><span class="p">,</span> <span class="n">p_venous</span><span class="p">,</span>
                         <span class="n">Vp</span><span class="p">,</span> <span class="n">Vvel</span><span class="p">,</span> <span class="n">K2_space</span><span class="p">,</span> <span class="n">configs</span><span class="p">,</span> <span class="n">myResults</span><span class="p">,</span> <span class="n">compartmental_model</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">timestep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute projected variables (perfusion, velocities, etc.) and store them in myResults.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">      p                : The pressure Function (either mixed or scalar).</span>
<span class="sd">      K1, K2, K3       : Permeability tensor Functions.</span>
<span class="sd">      beta12, beta23   : Coupling coefficients.</span>
<span class="sd">      p_venous         : Venous pressure (numeric).</span>
<span class="sd">      Vp               : Pressure function space.</span>
<span class="sd">      Vvel             : Velocity function space.</span>
<span class="sd">      K2_space         : Function space for L² projection (e.g. for beta_total).</span>
<span class="sd">      configs          : Configuration dictionary.</span>
<span class="sd">      myResults        : Dictionary to store output variables.</span>
<span class="sd">      compartmental_model : String, either &#39;acv&#39; (mixed) or &#39;a&#39; (scalar).</span>
<span class="sd">      rank             : MPI rank.</span>
<span class="sd">      </span>
<span class="sd">    Returns:</span>
<span class="sd">      myResults: The updated results dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">print0</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">save_data</span> <span class="o">=</span> <span class="n">kwarg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;save_data&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">out_vars</span>  <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="s2">&quot;res_vars&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_vars</span><span class="p">:</span>
        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;No variables defined to save.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">myResults</span>

    <span class="c1"># --- β_total ---</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Projecting beta_total...&quot;</span><span class="p">)</span>
    <span class="n">beta_total</span> <span class="o">=</span> <span class="n">project_expression</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">beta12</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">beta23</span><span class="p">),</span> <span class="n">K2_space</span><span class="p">)</span>

    <span class="c1"># --- Pressures &amp; perfusion ---</span>
    <span class="k">if</span> <span class="n">compartmental_model</span> <span class="o">==</span> <span class="s2">&quot;acv&quot;</span><span class="p">:</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;perfusion&quot;</span> <span class="ow">in</span> <span class="n">out_vars</span><span class="p">:</span>
            <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Projecting perfusion (acv)...&quot;</span><span class="p">)</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;perfusion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">project_expression</span><span class="p">(</span><span class="n">beta12</span><span class="o">*</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="p">),</span> <span class="n">K2_space</span><span class="p">)</span>
        <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">project_expression</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">K2_space</span><span class="p">)</span>
        <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">project_expression</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">K2_space</span><span class="p">)</span>
        <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">project_expression</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="n">K2_space</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">compartmental_model</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Duplicating scalar p for model &#39;a&#39;...&quot;</span><span class="p">)</span>
        <span class="n">p1f</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">function_space</span><span class="p">);</span> <span class="n">p1f</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>
        <span class="n">p3f</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">function_space</span><span class="p">);</span> <span class="n">p3f</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">p_venous</span>
        <span class="n">p2f</span> <span class="o">=</span> <span class="n">project_expression</span><span class="p">((</span><span class="n">beta12</span><span class="o">*</span><span class="n">p1f</span> <span class="o">+</span> <span class="n">beta23</span><span class="o">*</span><span class="n">p3f</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">beta12</span> <span class="o">+</span> <span class="n">beta23</span><span class="p">),</span> <span class="n">Vp</span><span class="p">)</span>
        <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press1&quot;</span><span class="p">],</span> <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press2&quot;</span><span class="p">],</span> <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1f</span><span class="p">,</span> <span class="n">p2f</span><span class="p">,</span> <span class="n">p3f</span>
        <span class="k">if</span> <span class="s2">&quot;perfusion&quot;</span> <span class="ow">in</span> <span class="n">out_vars</span><span class="p">:</span>
            <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Projecting perfusion (a)...&quot;</span><span class="p">)</span>
            <span class="n">const_v</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">p_venous</span><span class="p">)</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;perfusion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">project_expression</span><span class="p">(</span>
                <span class="n">beta_total</span><span class="o">*</span><span class="p">(</span><span class="n">p1f</span> <span class="o">-</span> <span class="n">const_v</span><span class="p">),</span> <span class="n">K2_space</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown model type: </span><span class="si">{</span><span class="n">compartmental_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Copy permeabilities &amp; couplings</span>
    <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;K1&quot;</span><span class="p">],</span> <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;K2&quot;</span><span class="p">],</span> <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;K3&quot;</span><span class="p">]</span>     <span class="o">=</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">K3</span>
    <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;beta12&quot;</span><span class="p">],</span> <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;beta23&quot;</span><span class="p">]</span>             <span class="o">=</span> <span class="n">beta12</span><span class="p">,</span> <span class="n">beta23</span>

    <span class="c1"># --- Velocities via interpolation ---</span>
    <span class="k">if</span> <span class="s2">&quot;vel1&quot;</span> <span class="ow">in</span> <span class="n">out_vars</span><span class="p">:</span>
        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Interpolating vel1...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compartmental_model</span> <span class="o">==</span> <span class="s2">&quot;acv&quot;</span><span class="p">:</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;vel1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate_tensor_expression</span><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="n">Vvel</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;vel1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate_tensor_expression</span><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press1&quot;</span><span class="p">]),</span> <span class="n">Vvel</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;vel2&quot;</span> <span class="ow">in</span> <span class="n">out_vars</span><span class="p">:</span>
        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Interpolating vel2...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compartmental_model</span> <span class="o">==</span> <span class="s2">&quot;acv&quot;</span><span class="p">:</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;vel2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate_expression</span><span class="p">(</span><span class="o">-</span><span class="n">K2</span><span class="o">*</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">p2</span><span class="p">),</span> <span class="n">Vvel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;vel2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate_expression</span><span class="p">(</span><span class="o">-</span><span class="n">K2</span><span class="o">*</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press2&quot;</span><span class="p">]),</span> <span class="n">Vvel</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;vel3&quot;</span> <span class="ow">in</span> <span class="n">out_vars</span><span class="p">:</span>
        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Interpolating vel3...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compartmental_model</span> <span class="o">==</span> <span class="s2">&quot;acv&quot;</span><span class="p">:</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;vel3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate_tensor_expression</span><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">p3</span><span class="p">),</span> <span class="n">Vvel</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;vel3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate_tensor_expression</span><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">myResults</span><span class="p">[</span><span class="s2">&quot;press3&quot;</span><span class="p">]),</span> <span class="n">Vvel</span><span class="p">)</span>


    <span class="c1"># Save in parallel</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;HDF5_USE_FILE_LOCKING&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;FALSE&quot;</span>
    <span class="k">if</span> <span class="n">save_data</span><span class="p">:</span>
        <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;compute_my_variables: Saving results in parallel...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">out_vars</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Saving results (parallel)&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">myResults</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">myResults</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
                <span class="n">path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">configs</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;res_fldr&#39;</span><span class="p">]</span><span class="si">}{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">timestep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">timestep</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">xdmf_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">.xdmf&quot;</span>

                <span class="c1"># Remove existing files on all ranks</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="n">path</span><span class="p">,</span> <span class="n">xdmf_path</span><span class="p">]:</span>
                    <span class="k">try</span><span class="p">:</span> 
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># File doesn&#39;t exist, no need to remove</span>


                <span class="n">var_to_save</span> <span class="o">=</span> <span class="n">interpolate_to_mesh_order</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">mesh_order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">XDMFFile</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">xdmf_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">xdmf</span><span class="p">:</span>
                    <span class="n">xdmf</span><span class="o">.</span><span class="n">write_mesh</span><span class="p">(</span><span class="n">get_mesh_from_var</span><span class="p">(</span><span class="n">var_to_save</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">var_name</span> <span class="o">==</span> <span class="s2">&quot;perfusion&quot;</span><span class="p">:</span>
                        <span class="n">scaled</span> <span class="o">=</span> <span class="n">var_to_save</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">scaled</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="mi">6000</span>
                        <span class="n">xdmf</span><span class="o">.</span><span class="n">write_function</span><span class="p">(</span><span class="n">scaled</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xdmf</span><span class="o">.</span><span class="n">write_function</span><span class="p">(</span><span class="n">var_to_save</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print0</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] Warning: &#39;</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&#39; not in myResults and cannot be saved!&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">myResults</span></div>


<div class="viewcode-block" id="compute_subdm_vol">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.compute_subdm_vol">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_subdm_vol</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">n_labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the volume of each subdomain specified by &#39;labels&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">      mesh      : The mesh.</span>
<span class="sd">      subdomains: Mesh function with subdomain markers.</span>
<span class="sd">      labels    : List or array of subdomain IDs.</span>
<span class="sd">      n_labels  : Number of subdomains to integrate over.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">      volume: NumPy array of volumes for each subdomain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dV</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">subdomain_data</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">form</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">one</span> <span class="o">*</span> <span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
        <span class="n">volume</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">volume</span></div>


<div class="viewcode-block" id="compute_boundary_area">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.compute_boundary_area">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_boundary_area</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">n_labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the surface area for each specified boundary region in the mesh.</span>

<span class="sd">    This function calculates the geometric area of each boundary region identified</span>
<span class="sd">    by the given labels. The calculation properly handles parallel (MPI) computations</span>
<span class="sd">    by automatically summing contributions across all processes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : dolfinx.mesh.Mesh</span>
<span class="sd">        The computational mesh containing the domain geometry.</span>
<span class="sd">    </span>
<span class="sd">    boundaries : dolfinx.mesh.MeshTags</span>
<span class="sd">        Mesh tags identifying different boundary regions. The tags must be defined</span>
<span class="sd">        on the facets (dim-1 entities) of the mesh.</span>
<span class="sd">    </span>
<span class="sd">    labels : numpy.ndarray</span>
<span class="sd">        Array of integer labels specifying which boundary regions to measure.</span>
<span class="sd">    </span>
<span class="sd">    n_labels : int</span>
<span class="sd">        Number of boundary regions to process (length of labels array).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        An array of computed areas corresponding to each boundary label,</span>
<span class="sd">        ordered as per the input labels array. Units match mesh units squared.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function works in both serial and parallel (MPI) configurations.</span>
<span class="sd">    - For accurate results, boundary tags should not overlap (each facet should</span>
<span class="sd">      belong to at most one boundary region).</span>
<span class="sd">    - The total area of each boundary region is automatically summed across all</span>
<span class="sd">      MPI processes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Define integration measure for boundary facets with subdomain markers</span>
    <span class="n">dS</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries</span><span class="p">)</span>
    
    <span class="c1"># Create constant 1.0 function for area integration</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
    
    <span class="c1"># Initialize array to store areas for each boundary region</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing boundary areas...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate area for each boundary region</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># Current boundary label</span>
        
        <span class="c1"># Create UFL form for area integration (∫1 dS over boundary ID)</span>
        <span class="n">form</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">one</span> <span class="o">*</span> <span class="n">dS</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
        
        <span class="c1"># Assemble the scalar value (automatically handles MPI reduction)</span>
        <span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Boundary areas computation complete.&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="surface_integrate">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.surface_integrate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">surface_integrate</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">n_labels</span><span class="p">,</span> <span class="n">magn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute surface integrals of a variable over specified boundary facets.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">      variable: UFL expression or dolfinx Function.</span>
<span class="sd">      mesh    : The mesh.</span>
<span class="sd">      boundaries: Mesh function marking boundaries.</span>
<span class="sd">      labels  : List or array of boundary IDs.</span>
<span class="sd">      n_labels: Number of boundaries to integrate over.</span>
<span class="sd">      magn   : Boolean flag; if True, integrate the magnitude of &#39;variable&#39;.</span>
<span class="sd">      method : Integration method (&#39;auto&#39;, &#39;direct&#39;, or &#39;quadrature&#39;).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">      NumPy array of surface integrals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="n">get_num_components</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">dS</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries</span><span class="p">)</span>
    <span class="n">surface_integrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">ncomp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
            <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">form</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">variable</span> <span class="o">*</span> <span class="n">dS</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
            <span class="n">surface_integrals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">magn</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
            <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">form</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">variable</span><span class="p">))</span> <span class="o">*</span> <span class="n">dS</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
            <span class="n">surface_integrals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Compute flux (normal component)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
            <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">form</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">dS</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
            <span class="n">surface_integrals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">surface_integrals</span></div>


<div class="viewcode-block" id="volume_integrate">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.volume_integrate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">volume_integrate</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">n_labels</span><span class="p">,</span> <span class="n">magn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute volume integrals of a variable over subdomains.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">      variable: UFL expression or dolfinx Function.</span>
<span class="sd">      mesh    : The mesh.</span>
<span class="sd">      subdomains: Mesh function marking subdomains.</span>
<span class="sd">      labels  : List or array of subdomain IDs.</span>
<span class="sd">      n_labels: Number of subdomains to integrate over.</span>
<span class="sd">      magn   : Boolean flag; if True, integrate the magnitude of &#39;variable&#39;.</span>
<span class="sd">      method : Integration method (&#39;auto&#39;, &#39;direct&#39;, or &#39;quadrature&#39;).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">      NumPy array of volume integrals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="n">get_num_components</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">dV</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">subdomain_data</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span>
    <span class="n">volume_integrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">ncomp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
            <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">form</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">variable</span> <span class="o">*</span> <span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
            <span class="n">volume_integrals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">magn</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
            <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">form</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">variable</span><span class="p">))</span> <span class="o">*</span> <span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span>
            <span class="n">volume_integrals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: volumetric integration of non-scalar variables without magnitude not implemented!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">volume_integrals</span>
    
    <span class="k">return</span> <span class="n">volume_integrals</span></div>


<div class="viewcode-block" id="surface_ave">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.surface_ave">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">surface_ave</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">boundaries</span><span class="p">,</span><span class="n">vels</span><span class="p">,</span><span class="n">ps</span><span class="p">):</span>
    <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    
    <span class="n">boundary_labels</span><span class="p">,</span> <span class="n">n_labels</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>
    <span class="n">boundary_labels</span> <span class="o">=</span> <span class="n">boundary_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span>
    <span class="n">n_labels</span> <span class="o">=</span> <span class="n">n_labels</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">dS</span> <span class="o">=</span> <span class="n">ds</span><span class="p">(</span><span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries</span><span class="p">)</span>
    
    <span class="n">fluxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">surf_p_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p_pial_ave</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    
    
    <span class="n">total_area</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">pial_weighting_area</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pressure_weight</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># compute fluxes and surface area for each boundary region</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">boundary_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">dS</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="n">fluxes_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ID</span><span class="p">,</span> <span class="n">area</span> <span class="p">]</span>
        <span class="n">surf_p</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ID</span><span class="p">,</span> <span class="n">area</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">fluxes_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">assemble</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">vels</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">dS</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span> <span class="p">)</span>
            <span class="n">p_ave</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">dS</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">surf_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">p_ave</span><span class="o">/</span><span class="n">area</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">ID</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">p_pial_ave</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_pial_ave</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_ave</span>
        <span class="n">fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fluxes_ID</span><span class="p">)</span>
        <span class="n">surf_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf_p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ID</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">pial_weighting_area</span> <span class="o">=</span> <span class="n">pial_weighting_area</span> <span class="o">+</span> <span class="n">area</span>
    
    <span class="c1"># compute the net surface area and fluxes of compartments</span>
    <span class="n">fluxes_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">sum</span><span class="p">(</span><span class="n">boundary_labels</span><span class="p">),</span> <span class="n">total_area</span> <span class="p">]</span>
    <span class="n">surf_p</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">sum</span><span class="p">(</span><span class="n">boundary_labels</span><span class="p">),</span> <span class="n">total_area</span> <span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">fluxes_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">assemble</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">vels</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">surf_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">assemble</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">ds</span><span class="p">)</span><span class="o">/</span><span class="n">total_area</span> <span class="p">)</span>
    <span class="n">fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">fluxes_ID</span> <span class="p">)</span>
    <span class="n">surf_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf_p</span><span class="p">)</span>
    
    <span class="n">surf_p</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundary_labels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">boundary_labels</span><span class="p">),</span> <span class="n">pial_weighting_area</span><span class="p">,</span> <span class="n">p_pial_ave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">pial_weighting_area</span><span class="p">,</span> <span class="n">p_pial_ave</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">pial_weighting_area</span><span class="p">,</span> <span class="n">p_pial_ave</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">pial_weighting_area</span><span class="p">]</span>
    <span class="n">surf_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf_p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fluxes</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">surf_p_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="vol_ave">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.vol_ave">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vol_ave</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">subdomains</span><span class="p">,</span><span class="n">ps</span><span class="p">,</span><span class="n">vels</span><span class="p">):</span>
    <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    
    <span class="n">subdom_labels</span><span class="p">,</span> <span class="n">n_labels</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span>
    
    <span class="n">dV</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">subdomain_data</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span>
    
    <span class="n">vel_mag</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vol_p_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vol_vel_values</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="c1"># compute volume and characteristic values for each region</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">subdom_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">char_p_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ID</span><span class="p">,</span> <span class="n">vol</span> <span class="p">]</span>
        <span class="n">char_vel_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ID</span><span class="p">,</span> <span class="n">vol</span> <span class="p">]</span>
        
        <span class="c1"># volume averaged quantities</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">char_p_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">vol</span> <span class="p">)</span>
            <span class="n">char_vel_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">vels</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">vels</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">*</span><span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">vol</span> <span class="p">)</span>
        
        <span class="c1"># TODO: add min and max</span>
        <span class="n">vol_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_p_ID</span><span class="p">)</span>
        <span class="n">vol_vel_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_vel_ID</span><span class="p">)</span>
    
    <span class="c1"># compute the net volume and average</span>
    <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">subdom_labels</span><span class="p">))</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">char_p_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ID</span><span class="p">,</span> <span class="n">vol</span> <span class="p">]</span>
    <span class="n">char_vel_ID</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ID</span><span class="p">,</span> <span class="n">vol</span> <span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">char_p_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">assemble</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span><span class="o">/</span><span class="n">vol</span> <span class="p">)</span>
        <span class="n">char_vel_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">assemble</span><span class="p">(</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">vels</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">vels</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">*</span><span class="n">dx</span> <span class="p">)</span><span class="o">/</span><span class="n">vol</span> <span class="p">)</span>
    
    <span class="n">vol_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_p_ID</span><span class="p">)</span>
    <span class="n">vol_vel_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_vel_ID</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol_p_values</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol_vel_values</span><span class="p">)</span></div>


<span class="c1">#%%</span>
<span class="c1">#----------------------------------------Geometry &amp; Mesh Handling--------------------------------------------</span>
<div class="viewcode-block" id="comp_vessel_orientation">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.comp_vessel_orientation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">comp_vessel_orientation</span><span class="p">(</span>
        <span class="n">subdomains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">MeshTags</span><span class="p">],</span> 
        <span class="n">boundaries</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">MeshTags</span><span class="p">],</span> 
        <span class="n">mesh</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="p">],</span> 
        <span class="n">res_fldr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
        <span class="n">save_subres</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute blood vessel orientation and main direction using a </span>
<span class="sd">    finite element method to solve the Poisson equation.</span>

<span class="sd">    First, a scalar function defining brain thickness is computed. For</span>
<span class="sd">    this, Dirichlet BCs are applied to pial and ventricular surfaces.</span>
<span class="sd">    Then, the variational problem is solved using a FEM, and the result </span>
<span class="sd">    is stored in pe.xdmf. Next, the local direction of blood vessels is</span>
<span class="sd">    calculated. The gradient of the thickness function is projected</span>
<span class="sd">    onto a different function space determined by fe_degr. This is then</span>
<span class="sd">    interpolated onto piecewise-constant, discontinuous space for</span>
<span class="sd">    data storage and visualisation purposes. The variational problem</span>
<span class="sd">    for local direction is solved, and the result is normalised to </span>
<span class="sd">    remove magnitude. The main direction is calculated by selecting</span>
<span class="sd">    the dominant component of each 3D e_local vector; therefore </span>
<span class="sd">    main_direction is one third the length of e_local. Both are 1D</span>
<span class="sd">    NumPy arrays when returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    subdomains : dolfinx.mesh.MeshTags</span>
<span class="sd">        DOLFINx object containing subdomain meshtags. </span>
<span class="sd">        These are specific volume regions of the mesh.</span>
<span class="sd">    boundaries : dolfinx.mesh.MeshTags</span>
<span class="sd">        DOLFINx object containing boundary meshtags.</span>
<span class="sd">        These are surface regions of the mesh specified for applying boundaries.</span>
<span class="sd">    mesh : dolfinx.mesh.Mesh</span>
<span class="sd">        DOLFINx object containing the mesh data.</span>
<span class="sd">    res_fldr : str</span>
<span class="sd">        This is a string pointing to the results directory.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e : np.ndarray</span>
<span class="sd">        1D NumPy array containing unit vectors of vessel directions at the </span>
<span class="sd">        DoFs.</span>
<span class="sd">    main_direction : np.ndarray</span>
<span class="sd">        1D NumPy array containing 0,1,2 per vector to signify the dominant </span>
<span class="sd">        direction x, y, or z.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">print0</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step 2.1: COMPUTING SCALAR THICKNESS FIELD&quot;</span><span class="p">)</span>
    
    <span class="n">fe_degr</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">print0</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step 2.1.2: fe_degr == </span><span class="si">{</span><span class="n">fe_degr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Scalar function space for the thickness values.</span>
    <span class="n">Vpe</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="n">fe_degr</span><span class="p">))</span>
    
    <span class="n">pe_in</span>  <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Pial surface</span>
    <span class="n">pe_out</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Ventricular surface</span>

    <span class="c1"># NOTATION:</span>
    <span class="c1"># 0: Interior surfaces, 1: Brainstem-cut plane,</span>
    <span class="c1"># 2: Ventricular surface, 2+: Brain surface (pial)</span>

    <span class="c1"># VENTRICULAR SURFACE</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 2.1.3: Applying Dirichlet BC to ventricular surface&quot;</span><span class="p">)</span>
    <span class="n">facet_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundaries</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">boundaries</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">boundary_dofs</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">locate_dofs_topological</span><span class="p">(</span><span class="n">Vpe</span><span class="p">,</span> <span class="n">entity_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">entities</span><span class="o">=</span><span class="n">facet_indices</span><span class="p">)</span>
    <span class="n">BCs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fem</span><span class="o">.</span><span class="n">dirichletbc</span><span class="p">(</span><span class="n">pe_out</span><span class="p">,</span> <span class="n">boundary_dofs</span><span class="p">,</span> <span class="n">Vpe</span><span class="p">)]</span>

    <span class="c1"># PIAL SURFACE</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 2.1.4: Applying Dirichlet BC to pial regions&quot;</span><span class="p">)</span>
    <span class="n">boundary_labels</span><span class="p">,</span> <span class="n">n_labels</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>
    <span class="n">print0</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step 2.1.5: Found </span><span class="si">{</span><span class="n">n_labels</span><span class="si">}</span><span class="s2"> pial boundary labels&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">boundary_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">facet_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundaries</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">boundaries</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">boundary_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">boundary_dofs</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">locate_dofs_topological</span><span class="p">(</span><span class="n">Vpe</span><span class="p">,</span> <span class="n">entity_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">entities</span><span class="o">=</span><span class="n">facet_indices</span><span class="p">)</span>
            <span class="n">BCs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">dirichletbc</span><span class="p">(</span><span class="n">pe_in</span><span class="p">,</span> <span class="n">boundary_dofs</span><span class="p">,</span> <span class="n">Vpe</span><span class="p">))</span>
    

    <span class="c1"># SOLVE FOR SCALAR THICKNESS FIELD</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 2.1.6: Solving variational problem for thickness&quot;</span><span class="p">)</span>
    <span class="c1"># NOTE: add a progress bar?</span>
    <span class="n">pe_trial</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">Vpe</span><span class="p">)</span>
    <span class="n">ve_test</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">Vpe</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">LHS</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">pe_trial</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">ve_test</span><span class="p">))</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>  <span class="c1"># Bilinear form</span>
    <span class="n">RHS</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">ve_test</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>  <span class="c1"># Linear form</span>
    <span class="c1"># Initialise the function pe in the predefined function space</span>
    <span class="n">pe</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">Vpe</span><span class="p">)</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">LinearProblem</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">BCs</span><span class="p">,</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bcgs&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;hypre&quot;</span><span class="p">})</span>
    <span class="n">pe</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 2.1.7: Solved for scalar field of thickness&quot;</span><span class="p">)</span>
    <span class="c1"># Lower the order to save or visualise the solution</span>
    <span class="n">V_write</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">pe_interpolated</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V_write</span><span class="p">)</span>
    <span class="n">pe_interpolated</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">XDMFFile</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">res_fldr</span> <span class="o">+</span> <span class="s1">&#39;pe.xdmf&#39;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">myfile</span><span class="p">:</span>
        <span class="n">myfile</span><span class="o">.</span><span class="n">write_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>  <span class="c1"># NOTE: needed?</span>
        <span class="n">myfile</span><span class="o">.</span><span class="n">write_function</span><span class="p">(</span><span class="n">pe_interpolated</span><span class="p">)</span>


    <span class="c1">#-------------------------</span>
    <span class="c1"># LOCAL DIRECTION STUFF</span>
    <span class="c1">#-------------------------</span>
    <span class="c1"># NOTE: add to top of function instead?</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 2.2.1: COMPUTING LOCAL BLOOD VESSEL DIRECTION&quot;</span><span class="p">)</span>
    <span class="c1"># Define function spaces based on fe_degr </span>
    <span class="k">if</span> <span class="n">fe_degr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Vector element for DG degree 0</span>
        <span class="c1"># A function space for piecewise constant vectors over tetrahedra</span>
        <span class="n">element_vec</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">ufl</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="s2">&quot;tetrahedron&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
        <span class="n">Ve</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">element_vec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Vector element for Lagrange and DG degree (fe_degr-1)</span>
        <span class="n">element_vec_lagrange</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">ufl</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="s2">&quot;tetrahedron&quot;</span><span class="p">,</span> <span class="n">fe_degr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
        <span class="n">Ve</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">element_vec_lagrange</span><span class="p">)</span>

        <span class="c1"># DG degree 0 element for Ve_DG</span>
        <span class="n">element_vec_DG</span> <span class="o">=</span> <span class="n">basix</span><span class="o">.</span><span class="n">ufl</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="s2">&quot;tetrahedron&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
        <span class="n">Ve_DG</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">element_vec_DG</span><span class="p">)</span>

    <span class="c1"># SOLVE FE PROBLEM FOR PROJECTION </span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 2.2.2: Solving FE problem for projection of -grad(pe) onto Ve&quot;</span><span class="p">)</span>
    <span class="n">u_proj</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
    <span class="n">v_proj</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
    <span class="n">f_expr</span> <span class="o">=</span> <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span>
    <span class="n">a_proj</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">u_proj</span><span class="p">,</span> <span class="n">v_proj</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">L_proj</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">f_expr</span><span class="p">,</span> <span class="n">v_proj</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">problem_proj</span> <span class="o">=</span> <span class="n">LinearProblem</span><span class="p">(</span><span class="n">a_proj</span><span class="p">,</span> <span class="n">L_proj</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[],</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bcgs&quot;</span><span class="p">})</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">problem_proj</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="c1"># SOLVE FE PROBLEM FOR INTERPOLATION</span>
    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Step 2.2.3: Solving FE problem for interpolation onto lower order function space&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fe_degr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Cell-averaging evaluation</span>
        <span class="c1"># Negligible difference with Legacy after normalisation</span>
        <span class="n">u_dg</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">Ve_DG</span><span class="p">)</span>
        <span class="n">v_dg</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">Ve_DG</span><span class="p">)</span>
        <span class="n">a_proj_dg</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">u_dg</span><span class="p">,</span> <span class="n">v_dg</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">L_proj_dg</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">v_dg</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">problem_proj_dg</span> <span class="o">=</span> <span class="n">LinearProblem</span><span class="p">(</span><span class="n">a_proj_dg</span><span class="p">,</span> <span class="n">L_proj_dg</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[],</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;bcgs&quot;</span><span class="p">})</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">problem_proj_dg</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Step 2.2.3: Completed - interpolated via L² projection&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">E</span>
        <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Step 2.2.3: Passing because already DG, 0-th order&#39;</span><span class="p">)</span>

    <span class="c1"># NORMALISE E</span>
    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Step 2.2.4: Normalising the direction vector field&#39;</span><span class="p">)</span>
    <span class="n">e_array</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e_array</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)):</span>
        <span class="n">norm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">norm_val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm_val</span>
    <span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">e_array</span>


    <span class="c1">#------------------------</span>
    <span class="c1"># MAIN DIRECTION STUFF</span>
    <span class="c1">#------------------------</span>
    <span class="c1"># Define Vdir (using a DG0 space for scalar values)</span>
    <span class="n">Vdir</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">functionspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Compute main direction of the vessels</span>
    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;step 2.3.1: COMPUTING MAIN DIRECTION&#39;</span><span class="p">)</span>
    <span class="n">main_direction</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">Vdir</span><span class="p">)</span>
    <span class="n">main_direction_array</span> <span class="o">=</span> <span class="n">main_direction</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e_array</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">main_direction_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_direction_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># or some default value</span>

    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Step 2.3.1: Main direction loop complete&#39;</span><span class="p">)</span>
    <span class="n">main_direction</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">main_direction_array</span>
    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Step 2.3: Complete - finished computing vessel orientation and main direction&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">main_direction</span></div>


<div class="viewcode-block" id="comp_transf_mat">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.comp_transf_mat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">comp_transf_mat</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span><span class="n">e1</span><span class="p">):</span>
<span class="c1">#    # formulation #1</span>
<span class="c1">#    # (rotation in the plane with a normal vector formed by e1 x e2)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c1"># sine</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span> <span class="c1"># cosine</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># identity matrix</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">s</span>
    <span class="n">ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1">#    </span>
<span class="c1">#    # transformation matrix</span>
<span class="c1">#    # based on https://en.wikipedia.org/wiki/Rotation_matrix#General_rotations</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">I</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">ux</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#    # formulation #2    </span>
<span class="c1">#    T = np.array([</span>
<span class="c1">#            [c+u[0]**2*(1-c),u[0]*u[1]*(1-c)-u[2]*s,u[0]*u[2]*(1-c)+u[1]*s],</span>
<span class="c1">#            [u[1]*u[0]*(1-c)+u[2]*s,c+u[1]**2*(1-c),u[1]*u[2]*(1-c)+u[0]*s],</span>
<span class="c1">#            [u[0]*u[2]*(1-c)+u[1]*s,u[2]*u[1]*(1-c)+u[0]*s,c+u[2]**2*(1-c)]])</span>
    
<span class="c1">#    # formulation #3</span>
<span class="c1">#    v = np.cross(e0,e1)</span>
<span class="c1">#    s = np.linalg.norm(v) # sine</span>
<span class="c1">#    rot_vec = v/s*np.arcsin(s)</span>
<span class="c1">#    transformation_matrix = R.from_rotvec(rot_vec)</span>
<span class="c1">#    T = transformation_matrix.as_dcm()</span>
    <span class="k">return</span> <span class="n">T</span></div>


<div class="viewcode-block" id="get_mesh_from_var">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.get_mesh_from_var">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_mesh_from_var</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the mesh from a variable if it&#39;s a Function or UFL expression with function_space&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s2">&quot;function_space&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s2">&quot;ufl_function_space&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">ufl_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot extract mesh from variable of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_num_components">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.get_num_components">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_num_components</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of components per cell in the function &#39;var&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">      var    : A dolfinx Function.</span>
<span class="sd">      mesh   : The mesh on which &#39;var&#39; is defined.</span>
<span class="sd">      method : Method to compute number of components (&#39;auto&#39;, &#39;direct&#39;, or &#39;quadrature&#39;).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">      Number of components (an integer).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_cells</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">index_map</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">size_local</span>
    <span class="k">if</span> <span class="n">n_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">element</span>

    <span class="c1"># Handle mixed spaces: if there are sub-spaces, return their count.</span>
    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">num_sub_spaces</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">num_sub_spaces</span>

    <span class="c1"># Detect if element is a Basix element (FEniCSx 0.9)</span>
    <span class="n">is_basix</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">basix</span><span class="o">.</span><span class="n">ufl</span><span class="o">.</span><span class="n">_BasixElement</span><span class="p">)</span>
    <span class="n">is_blocked</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">&quot;block_size&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">element</span><span class="o">.</span><span class="n">block_size</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;quadrature&quot;</span> <span class="k">if</span> <span class="n">is_basix</span> <span class="ow">or</span> <span class="n">is_blocked</span> <span class="k">else</span> <span class="s2">&quot;direct&quot;</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;direct&quot;</span><span class="p">:</span>
        <span class="c1"># Ensure proper integer division rounding</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">total</span> <span class="o">+</span> <span class="n">n_cells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_cells</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;quadrature&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">value_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method: choose &#39;auto&#39;, &#39;direct&#39;, or &#39;quadrature&#39;&quot;</span><span class="p">)</span></div>


<span class="c1">#%%</span>
<span class="c1">#----------------------------------------Physical &amp; Biophysical properties--------------------------------------------</span>

<div class="viewcode-block" id="scale_coupling_coefficients">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.scale_coupling_coefficients">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">scale_coupling_coefficients</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> 
                                <span class="n">beta12gm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                                <span class="n">beta23gm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                                <span class="n">gmowm_beta_rat</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                                <span class="n">K2_space</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">],</span> 
                                <span class="n">res_fldr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                                <span class="o">**</span><span class="n">kwarg</span>
                                <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">fem</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">]:</span> 

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scale and distribute coupling coefficients between gray and white matter.</span>

<span class="sd">    1. Identifies white matter (tag 11) and gray matter (tag 12) regions</span>
<span class="sd">    2. Creates FEM functions for the coupling coefficients</span>
<span class="sd">    3. Assigns different coefficient values to GM and WM regions</span>
<span class="sd">    4. Validates the assignments with assertions</span>
<span class="sd">    5. Returns the configured coefficient functions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    subdomains : dolfinx.mesh.MeshTags</span>
<span class="sd">        Mesh tags identifying different tissue types</span>
<span class="sd">    beta12gm : float</span>
<span class="sd">        Coupling coefficient value for gray matter (β₁₂)</span>
<span class="sd">    beta23gm : float</span>
<span class="sd">        Coupling coefficient value for gray matter (β₂₃)</span>
<span class="sd">    gmowm_beta_rat : float</span>
<span class="sd">        Ratio of GM to WM coupling coefficients</span>
<span class="sd">    K2_space : dolfinx.fem.FunctionSpace</span>
<span class="sd">        Function space for the coupling coefficients</span>
<span class="sd">    res_fldr : str</span>
<span class="sd">        Results directory path (unused in function but kept for interface consistency)</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Additional keyword arguments for future extensibility</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[fem.Function, fem.Function]</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        - beta12: Coupling coefficient function β₁₂ (GM→WM)</span>
<span class="sd">        - beta23: Coupling coefficient function β₂₃ (WM→GM)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - White matter is identified by tag 11</span>
<span class="sd">    - Gray matter is identified by tag 12</span>
<span class="sd">    - WM coefficients are GM coefficients divided by gmowm_beta_rat</span>
<span class="sd">    - Includes extensive debug printing and validation</span>
<span class="sd">    &quot;&quot;&quot;</span>                      
    
    <span class="n">loc1</span> <span class="o">=</span> <span class="n">subdomains</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)]</span>  <span class="c1"># white matter cell indices</span>
    <span class="n">loc2</span> <span class="o">=</span> <span class="n">subdomains</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)]</span>  <span class="c1"># gray matter cell indices</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Debug: loc1 (WM) indices:&quot;</span><span class="p">,</span> <span class="n">loc1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Debug: loc2 (GM) indices:&quot;</span><span class="p">,</span> <span class="n">loc2</span><span class="p">)</span>

    <span class="n">beta12</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">K2_space</span><span class="p">)</span>
    <span class="n">beta23</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">K2_space</span><span class="p">)</span>
    
    <span class="n">beta12_array</span> <span class="o">=</span> <span class="n">beta12</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>
    <span class="n">beta23_array</span> <span class="o">=</span> <span class="n">beta23</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>

    <span class="c1"># Assign values</span>
    <span class="n">beta12_array</span><span class="p">[</span><span class="n">loc2</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta12gm</span>
    <span class="n">beta12_array</span><span class="p">[</span><span class="n">loc1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta12gm</span> <span class="o">/</span> <span class="n">gmowm_beta_rat</span>
    <span class="n">beta23_array</span><span class="p">[</span><span class="n">loc2</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta23gm</span>
    <span class="n">beta23_array</span><span class="p">[</span><span class="n">loc1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta23gm</span> <span class="o">/</span> <span class="n">gmowm_beta_rat</span>

    <span class="n">beta12</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">beta12_array</span>
    <span class="n">beta23</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">beta23_array</span>
    <span class="c1"># Assertions with tolerance</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">beta12_array</span><span class="p">[</span><span class="n">loc2</span><span class="p">],</span> <span class="n">beta12gm</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">),</span> <span class="s2">&quot;Mismatch in beta12 for GM&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">beta12_array</span><span class="p">[</span><span class="n">loc1</span><span class="p">],</span> <span class="n">beta12gm</span> <span class="o">/</span> <span class="n">gmowm_beta_rat</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">),</span> <span class="s2">&quot;Mismatch in beta12 for WM&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">beta23_array</span><span class="p">[</span><span class="n">loc2</span><span class="p">],</span> <span class="n">beta23gm</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">),</span> <span class="s2">&quot;Mismatch in beta23 for GM&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">beta23_array</span><span class="p">[</span><span class="n">loc1</span><span class="p">],</span> <span class="n">beta23gm</span> <span class="o">/</span> <span class="n">gmowm_beta_rat</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">),</span> <span class="s2">&quot;Mismatch in beta23 for WM&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Debug: scale_coupling_coefficients passed all checks!&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">beta12</span><span class="p">,</span> <span class="n">beta23</span></div>


<div class="viewcode-block" id="scale_permeabilities">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.scale_permeabilities">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">scale_permeabilities</span><span class="p">(</span>
    <span class="n">subdomains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">MeshTags</span><span class="p">],</span> 
    <span class="n">K1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">],</span> 
    <span class="n">K2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">],</span> 
    <span class="n">K3</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">],</span>
    <span class="n">K1_ref_gm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="n">K2_ref_gm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="n">K3_ref_gm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="n">gmowm_perm_rat</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">res_fldr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwarg</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale permeability tensors (K1, K2, K3) based on gray and white matter subdomains.</span>

<span class="sd">    1. Identifies gray and white matter cells using subdomain markers.</span>
<span class="sd">    2. Computes reference values for white matter by scaling gray matter values.</span>
<span class="sd">    3. Scales K1 and K3 tensors element-wise and assigns scalar values to K2.</span>
<span class="sd">    4. Updates the FEM Function arrays with the new scaled values.</span>
<span class="sd">    5. Returns the modified K1, K2, and K3 permeability fields.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    subdomains : dolfinx.mesh.MeshTags</span>
<span class="sd">        Subdomain tags identifying white matter (11) and gray matter (12).</span>

<span class="sd">    K1 : dolfinx.fem.Function</span>
<span class="sd">        Tensor-valued permeability for compartment 1 (to be scaled).</span>

<span class="sd">    K2 : dolfinx.fem.Function</span>
<span class="sd">        Scalar-valued permeability for compartment 2 (to be scaled).</span>

<span class="sd">    K3 : dolfinx.fem.Function</span>
<span class="sd">        Tensor-valued permeability for compartment 3 (to be scaled).</span>

<span class="sd">    K1_ref_gm : float</span>
<span class="sd">        Reference permeability for gray matter in compartment 1.</span>

<span class="sd">    K2_ref_gm : float</span>
<span class="sd">        Reference permeability for gray matter in compartment 2.</span>

<span class="sd">    K3_ref_gm : float</span>
<span class="sd">        Reference permeability for gray matter in compartment 3.</span>

<span class="sd">    gmowm_perm_rat : float</span>
<span class="sd">        Ratio of gray matter to white matter permeability. Used to compute</span>
<span class="sd">        reference values in WM from GM references.</span>

<span class="sd">    res_fldr : str</span>
<span class="sd">        Folder for saving output files (not used in this function but retained for consistency).</span>

<span class="sd">    **kwarg : dict</span>
<span class="sd">        Optional arguments (not used here).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of dolfinx.fem.Function</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        - K1 : dolfinx.fem.Function</span>
<span class="sd">            Scaled tensor field for compartment 1.</span>
<span class="sd">        - K2 : dolfinx.fem.Function</span>
<span class="sd">            Scaled scalar field for compartment 2.</span>
<span class="sd">        - K3 : dolfinx.fem.Function</span>
<span class="sd">            Scaled tensor field for compartment 3.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Writes scaled permeability values directly into K1, K2, and K3.</span>
<span class="sd">    White matter is scaled down according to `gmowm_perm_rat`, while gray</span>
<span class="sd">    matter uses the reference values directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;scale_permeabilities: Starting permeability scaling&quot;</span><span class="p">)</span>

    <span class="c1"># Step 1: Identify cell indices for WM and GM</span>
    <span class="n">loc1</span> <span class="o">=</span> <span class="n">subdomains</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)]</span>  <span class="c1"># white matter</span>
    <span class="n">loc2</span> <span class="o">=</span> <span class="n">subdomains</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)]</span>  <span class="c1"># gray matter</span>
    <span class="n">print0</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step 1: Located </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">loc1</span><span class="p">)</span><span class="si">}</span><span class="s2"> white matter cells and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">loc2</span><span class="p">)</span><span class="si">}</span><span class="s2"> gray matter cells&quot;</span><span class="p">)</span>

    <span class="c1"># Step 2: Access array representations of the fields</span>
    <span class="n">K1_array</span> <span class="o">=</span> <span class="n">K1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>
    <span class="n">K2_array</span> <span class="o">=</span> <span class="n">K2</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>
    <span class="n">K3_array</span> <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 2: Extracted array views of K1, K2, K3&quot;</span><span class="p">)</span>

    <span class="c1"># Step 3: Compute WM reference values from GM values</span>
    <span class="n">K1_ref_wm</span> <span class="o">=</span> <span class="n">K1_ref_gm</span> <span class="o">/</span> <span class="n">gmowm_perm_rat</span>
    <span class="n">K2_ref_wm</span> <span class="o">=</span> <span class="n">K2_ref_gm</span> <span class="o">/</span> <span class="n">gmowm_perm_rat</span>
    <span class="n">K3_ref_wm</span> <span class="o">=</span> <span class="n">K3_ref_gm</span> <span class="o">/</span> <span class="n">gmowm_perm_rat</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 3: Computed WM reference values from GM using gmowm_perm_rat&quot;</span><span class="p">)</span>

    <span class="c1"># Step 4: Apply scaling to each subdomain</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 4: Scaling permeability tensors&quot;</span><span class="p">)</span>
    <span class="n">location</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="p">[</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">)):</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mi">9</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">+</span> <span class="mi">9</span>
            <span class="k">if</span> <span class="n">location</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># white matter</span>
                <span class="n">K1_array</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">K1_ref_wm</span>
                <span class="n">K3_array</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">K3_ref_wm</span>
                <span class="n">K2_array</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">K2_ref_wm</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># gray matter</span>
                <span class="n">K1_array</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">K1_ref_gm</span>
                <span class="n">K3_array</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">K3_ref_gm</span>
                <span class="n">K2_array</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">K2_ref_gm</span>
        <span class="n">location</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 4.1: Completed element-wise scaling for both GM and WM&quot;</span><span class="p">)</span>

    <span class="c1"># Step 5: Update Function objects</span>
    <span class="n">K1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">K1_array</span>
    <span class="n">K2</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">K2_array</span>
    <span class="n">K3</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">K3_array</span>
    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Step 5: Function arrays updated with scaled values&quot;</span><span class="p">)</span>

    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;scale_permeabilities: Completed scaling and returning results&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">K3</span></div>


<div class="viewcode-block" id="perm_tens_comp">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.perm_tens_comp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">perm_tens_comp</span><span class="p">(</span>
        <span class="n">K_space</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">],</span>
        <span class="n">subdomains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">MeshTags</span><span class="p">],</span>
        <span class="n">mesh</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="p">],</span>
        <span class="n">e_ref</span><span class="p">,</span>
        <span class="n">e_loc</span><span class="p">,</span>
        <span class="n">K1_form</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a function which gives the rotated permeability tensor</span>
<span class="sd">    at every point in the brain, as it follows the local direction of </span>
<span class="sd">    blood vessels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    K_space : dolfinx.fem.function.FunctionSpace</span>
<span class="sd">        The function space defined for the permeabilities.</span>
<span class="sd">    subdomains : dolfinx.mesh.MeshTags</span>
<span class="sd">        Subdomains from the mesh.</span>
<span class="sd">    mesh : dolfinx.mesh.Mesh</span>
<span class="sd">        Information about the mesh.</span>
<span class="sd">    e_ref : type </span>
<span class="sd">        Direction vector representing vessel orientation at the reference point.</span>
<span class="sd">    e_loc : type</span>
<span class="sd">        The local direction vector.</span>
<span class="sd">    K1_form : type</span>
<span class="sd">        The normalised form of the permeability tensor at the reference point,</span>
<span class="sd">        to be rotated and scaled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    type</span>
<span class="sd">        Description of the return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the mesh&#39;s topological dimension</span>
    <span class="n">dim</span>   <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span>
    <span class="c1"># Get an index map of facets</span>
    <span class="n">imap</span>  <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">index_map</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="c1"># Get the local ownership rank</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">imap</span><span class="o">.</span><span class="n">local_range</span>
    <span class="c1"># Number of owned entities</span>
    <span class="n">local_count</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>

    <span class="c1"># Debug: input array and parameter shapes/types</span>
    <span class="c1"># Extract array from the function</span>
    <span class="n">e_loc_arr</span> <span class="o">=</span> <span class="n">e_loc</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span>

    <span class="c1"># Initialise a new function in K_space</span>
    <span class="n">K1</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">K_space</span><span class="p">)</span>
    <span class="n">K1_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] Initialized K1_arr dtype=</span><span class="si">{</span><span class="n">K1_arr</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">K1_arr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Loop over owned cells only (local indices)</span>
    <span class="k">for</span> <span class="n">local_cell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">local_cell</span> <span class="o">-</span> <span class="n">start</span>
        <span class="c1"># Extract local direction vector segment</span>
        <span class="n">segment_start</span> <span class="o">=</span> <span class="n">off</span><span class="o">*</span><span class="mi">3</span>
        <span class="n">segment_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">off</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">e_loc_arr</span><span class="p">[</span><span class="n">segment_start</span><span class="p">:</span><span class="n">segment_end</span><span class="p">]</span>
        <span class="c1"># Debug: e1 shape</span>
        <span class="k">if</span> <span class="n">e1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] WARNING: e1 slice shape mismatch at local_cell=</span><span class="si">{</span><span class="n">local_cell</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">e1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected (3,)&quot;</span><span class="p">)</span>

        <span class="c1"># Compute transformation matrix</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">comp_transf_mat</span><span class="p">(</span><span class="n">e_ref</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
        <span class="c1"># Debug: T shape and finite check</span>
        <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] WARNING: T shape mismatch at local_cell=</span><span class="si">{</span><span class="n">local_cell</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected (3,3)&quot;</span><span class="p">)</span>

        <span class="c1"># Rotate permeability tensor</span>
        <span class="n">K1_rot</span> <span class="o">=</span> <span class="n">T</span> <span class="o">@</span> <span class="n">K1_form</span> <span class="o">@</span> <span class="n">T</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Debug: rotated tensor shape and values</span>
        <span class="k">if</span> <span class="n">K1_rot</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] WARNING: K1_rot shape mismatch at local_cell=</span><span class="si">{</span><span class="n">local_cell</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">K1_rot</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected (3,3)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">K1_rot</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] WARNING: Non-finite values in K1_rot at local_cell=</span><span class="si">{</span><span class="n">local_cell</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">flat</span> <span class="o">=</span> <span class="n">K1_rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
        <span class="c1"># Debug: flat shape</span>
        <span class="k">if</span> <span class="n">flat</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] WARNING: flat reshape mismatch at local_cell=</span><span class="si">{</span><span class="n">local_cell</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">flat</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected (9,)&quot;</span><span class="p">)</span>
        <span class="c1"># Assign to output vector</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">off</span><span class="o">*</span><span class="mi">9</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">off</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">9</span>
        <span class="n">K1_arr</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">flat</span>

    <span class="c1"># Zero‐tolerance cleanup</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-9</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">K1_arr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="n">cleanup_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] Zeroing </span><span class="si">{</span><span class="n">cleanup_count</span><span class="si">}</span><span class="s2"> near-zero entries (tol=</span><span class="si">{</span><span class="n">tol</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="n">K1_arr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Assign to Function and sync ghost values</span>
    <span class="n">K1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">K1_arr</span>
    <span class="n">K1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">scatter_forward</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">] Completed perm_tens_comp and scattered forward&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">K1</span></div>


<div class="viewcode-block" id="set_coupling_coeff">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.set_coupling_coeff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_coupling_coeff</span><span class="p">(</span><span class="n">beta</span><span class="p">):</span>
    <span class="n">beta12</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">beta13</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">beta23</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="n">beta21</span> <span class="o">=</span> <span class="n">beta12</span>
    <span class="n">beta31</span> <span class="o">=</span> <span class="n">beta13</span>
    <span class="n">beta32</span> <span class="o">=</span> <span class="n">beta23</span>
    
    <span class="k">return</span> <span class="n">beta12</span><span class="p">,</span> <span class="n">beta13</span><span class="p">,</span> <span class="n">beta21</span><span class="p">,</span> <span class="n">beta23</span><span class="p">,</span> <span class="n">beta31</span><span class="p">,</span> <span class="n">beta32</span></div>


<span class="c1">#%%</span>
<span class="c1">#----------------------------------------Domain &amp; Region Handling--------------------------------------------</span>
<div class="viewcode-block" id="infarct_vol">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.infarct_vol">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">infarct_vol</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">,</span> <span class="n">infarct</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the volume and infarct volume for each subdomain region in the mesh.</span>

<span class="sd">    This function calculates both the geometric volume and the integrated infarct</span>
<span class="sd">    volume (converted to mL) for each labeled subdomain region. The infarct volume</span>
<span class="sd">    represents the amount of damaged tissue in each region, weighted by the </span>
<span class="sd">    provided infarct field values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : dolfinx.mesh.Mesh</span>
<span class="sd">        The computational mesh containing the domain geometry.</span>
<span class="sd">    </span>
<span class="sd">    subdomains : dolfinx.mesh.MeshTags</span>
<span class="sd">        Mesh tags identifying different tissue regions (11=white matter, 12=gray matter).</span>
<span class="sd">        The tags must be defined on the cells of the mesh.</span>
<span class="sd">    </span>
<span class="sd">    infarct : dolfinx.fem.Function</span>
<span class="sd">        A DG0 function representing the infarct field (damage level) with values </span>
<span class="sd">        between 0 (healthy) and 1 (fully damaged) for each cell.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        An array with rows for each region containing:</span>
<span class="sd">        [region_id, volume (mm³), infarct_volume (mL)]</span>
<span class="sd">        The last row contains the totals across all regions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function works in parallel (MPI) and properly handles distributed meshes.</span>
<span class="sd">    - Volumes are computed by integrating 1 over each subdomain.</span>
<span class="sd">    - Infarct volumes are computed by integrating the infarct field and converting</span>
<span class="sd">      from mm³ to mL (dividing by 1000).</span>
<span class="sd">    - The total region (sum of all subdomain IDs) is automatically computed.</span>
<span class="sd">    - The infarct field should be a discontinuous (DG0) function for accurate integration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>

    <span class="c1"># Get unique subdomain labels and count</span>
    <span class="n">subdom_labels</span><span class="p">,</span> <span class="n">n_labels</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span>

    <span class="c1"># Create measure with subdomain data for integration</span>
    <span class="n">dV</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s2">&quot;dx&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span>
    
    <span class="n">vol_p_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Compute volume and infarct values for each region</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">subdom_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># Compute geometric volume of the region</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">)))</span>
        <span class="n">char_p_ID</span> <span class="o">=</span> <span class="p">[</span><span class="n">ID</span><span class="p">,</span> <span class="n">vol</span><span class="p">]</span>

        <span class="c1"># Compute infarct volume (integrate field and convert to mL)</span>
        <span class="n">char_p_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">(</span><span class="n">infarct</span> <span class="o">*</span> <span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">)))</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
        <span class="n">vol_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_p_ID</span><span class="p">)</span>

    <span class="c1"># Compute the net volume and infarct across all regions</span>
    <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">subdom_labels</span><span class="p">))</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">(</span><span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">(</span><span class="n">mesh</span><span class="p">)))</span>
    <span class="n">char_p_ID</span> <span class="o">=</span> <span class="p">[</span><span class="n">ID</span><span class="p">,</span> <span class="n">vol</span><span class="p">]</span>

    <span class="c1"># Compute total infarct volume across all regions</span>
    <span class="n">char_p_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">form</span><span class="p">(</span><span class="n">infarct</span> <span class="o">*</span> <span class="n">dx</span><span class="p">(</span><span class="n">mesh</span><span class="p">)))</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">vol_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_p_ID</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol_p_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="region_label_assembler">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.region_label_assembler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">region_label_assembler</span><span class="p">(</span><span class="n">region</span> <span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">MeshTags</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of unique region tags and how many unique regions there are.</span>

<span class="sd">    The 2,164,216 faces from the mesh are split between each process, and the </span>
<span class="sd">    attached meshtags are noted. The integer tags are recast. A list of the number </span>
<span class="sd">    of faces that each process has managed is gathered in an array on the root </span>
<span class="sd">    using comm.Gather. This is summed, and an empty receive array is created of </span>
<span class="sd">    the proper size. Then comm.Gatherv receives each process&#39; list of tags and </span>
<span class="sd">    concatenates them into a single list on the root. The root calculates the </span>
<span class="sd">    list of unique labels and the number of unique labels. These are then </span>
<span class="sd">    broadcasted to the processes as a tuple containing a NumPy array and an integer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    region: dolfinx.mesh.Meshtags</span>
<span class="sd">        The boundary facet meshtags from mesh_reader</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    region_labels : np.array.int64</span>
<span class="sd">        A NumPy array of unique labels; now identical on all processes.</span>

<span class="sd">    n_labels : int</span>
<span class="sd">        An integer count of unique labels; now identical on all processes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - For this particular clustered.xdmf mesh:</span>
<span class="sd">    - 1,042,301 cells</span>
<span class="sd">    - 2,164,216 facets (in the whole mesh, with no repeats)</span>
<span class="sd">    - 159,228 facets on a boundary</span>

<span class="sd">    &quot;&quot;&quot;</span>     
    
    <span class="c1"># Access tags from facets counted by process</span>
    <span class="n">region_labels</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">values</span>  
    
    <span class="c1"># NOTE: necessary? Surely all the tags are positive integers?</span>
    <span class="c1"># Cast to int64</span>
    <span class="n">region_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">region_labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="c1"># Force into positive int32 range</span>
    <span class="n">region_labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">region_labels</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    
    
    <span class="c1"># Package data</span>
    <span class="n">sendbuf</span> <span class="o">=</span> <span class="n">region_labels</span>
    <span class="c1"># Gathers the length of the locally computed facet tags</span>
    <span class="n">sendcounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sendbuf</span><span class="p">),</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">))</span>
    
    <span class="c1"># Creates an empty NumPy array on the root process</span>
    <span class="c1"># for storing all region labels</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="n">root</span><span class="p">:</span>
        <span class="n">recvbuf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">sendcounts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">recvbuf</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Collects all sendbuf arrays from each process and concatenates onto recvbuf on root</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Gatherv</span><span class="p">(</span><span class="n">sendbuf</span><span class="o">=</span><span class="n">sendbuf</span><span class="p">,</span> <span class="n">recvbuf</span><span class="o">=</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">,</span> <span class="n">sendcounts</span><span class="p">),</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="n">root</span><span class="p">:</span>
        <span class="c1"># Calculates the distinct labels</span>
        <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">)))</span>
        <span class="c1"># Calculates the number of distinct labels</span>
        <span class="n">n_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    
    <span class="c1"># Broadcast n_labels to all processes</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">n_labels</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
    
    <span class="c1"># Change name unique_labels to region_labels</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="n">root</span><span class="p">:</span>
        <span class="n">region_labels</span> <span class="o">=</span> <span class="n">unique_labels</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">region_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    
    <span class="c1"># Broadcast region_labels to all processes</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">region_labels</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
    
    <span class="c1"># Convert n_labels to scalar</span>
    <span class="n">n_labels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># Return tuple (region_labels, n_labels) or e.g. ([1, 2, ...], 2)</span>
    <span class="k">return</span> <span class="n">region_labels</span><span class="p">,</span> <span class="n">n_labels</span></div>


<div class="viewcode-block" id="perfusion_vol">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.perfusion_vol">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">perfusion_vol</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">subdomains</span><span class="p">,</span><span class="n">perfusion</span><span class="p">):</span>
    <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>

    <span class="n">subdom_labels</span><span class="p">,</span> <span class="n">n_labels</span> <span class="o">=</span> <span class="n">region_label_assembler</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span>

    <span class="n">dV</span> <span class="o">=</span> <span class="n">dx</span><span class="p">(</span><span class="n">subdomain_data</span><span class="o">=</span><span class="n">subdomains</span><span class="p">)</span>
    <span class="n">vol_p_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># compute volume and characteristic values for each region</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">subdom_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">))</span>
        <span class="n">char_p_ID</span> <span class="o">=</span> <span class="p">[</span><span class="n">ID</span><span class="p">,</span> <span class="n">vol</span><span class="p">]</span>

        <span class="c1"># volume averaged quantities</span>
        <span class="n">char_p_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">perfusion</span> <span class="o">*</span> <span class="n">dV</span><span class="p">(</span><span class="n">ID</span><span class="p">))</span> <span class="o">/</span> <span class="n">vol</span><span class="p">)</span>
        <span class="n">vol_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_p_ID</span><span class="p">)</span>

    <span class="c1"># compute the net volume and average</span>
    <span class="n">ID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">subdom_labels</span><span class="p">))</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">))</span>
    <span class="n">char_p_ID</span> <span class="o">=</span> <span class="p">[</span><span class="n">ID</span><span class="p">,</span> <span class="n">vol</span><span class="p">]</span>

    <span class="n">char_p_ID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">perfusion</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="o">/</span> <span class="n">vol</span><span class="p">)</span>
    <span class="n">vol_p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_p_ID</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol_p_values</span><span class="p">)</span></div>


<span class="c1">#%%</span>
<span class="c1">#----------------------------------------Output--------------------------------------------</span>
<div class="viewcode-block" id="write_results">
<a class="viewcode-back" href="../files/suppl_fcts.html#suppl_fcts.write_results">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_results</span><span class="p">(</span><span class="n">myResults</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;results&quot;</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">myResults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;function_space&quot;</span><span class="p">):</span>
            <span class="k">continue</span>  <span class="c1"># Skip scalars or non-function entries</span>
 
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">function_space</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">xdmf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.xdmf&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">XDMFFile</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">xdmf_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">xdmf</span><span class="p">:</span>
            <span class="n">xdmf</span><span class="o">.</span><span class="n">write_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="n">xdmf</span><span class="o">.</span><span class="n">write_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>


</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Gemini</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../files/background.html">Background Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/structure.html">Code Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/modernisation_concise.html">Modernisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/hpc.html">HPC Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/performance.html">Code Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/IO_fcts.html">IO_fcts module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/finite_element_fcts.html">finite_element_fcts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../files/suppl_fcts.html">suppl_fcts</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Adam Brierley.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>